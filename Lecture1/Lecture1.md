# Lecture 1: Understanding Memories
In this lecture I am going to cover:
* **ELF** files, how do they look **inside the memory** (during runtime).
* The organization of **Stack** during the function call.
* What is assembly? How do the assembly code looks.
* what are `$ebp` and `$esp`?

### ELF
> In computing, the Executable and Linkable Format (ELF, formerly named Extensible Linking Format), is a common standard file format for executable files, object code, shared libraries, and core dumps.
Ref : [ELF](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format)

Did that jumped over your head? Don't worry. Let me simplify it.
ELF is basically a format specifying how the code(binary code either executable or linkable) will look in to the memory. ELF headers contains lot of infomatiom about the ELF file content. One can use following command to view the headers of ELF. I am using it on one of the file of this repo.  
`readelf -h ./function_call`
```
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Intel 80386
  Version:                           0x1
  Entry point address:               0x8048310
  Start of program headers:          52 (bytes into file)
  Start of section headers:          6860 (bytes into file)
  Flags:                             0x0
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         9
  Size of section headers:           40 (bytes)
  Number of section headers:         36
  Section header string table index: 33
```
Notice two things for now, they will be important for the course as well:
1. **Type:** EXEC, meaning this particular binary file an executable one.
2. **Data:** 2's complement, **little endian**, meaning this file is compiled
for the machine that uses little endian notation for the address. [What are they ?](https://en.wikipedia.org/wiki/Endianness)

### How do ELF file looks in to the memory ?
```
                        +---------------+ Highest Address 0xffffffff
                        | cmd line args |
                        | env Variable  |
                        +---------------+
                        |     STACK     |
                        +--+------------+
                        |  |            |
                        |  |            |
                        |  v         ^  |
                        |            |  |
                        |            |  |
                        +------------+--+
                        |     HEAP      |
                        +---------------+
                        | Uninitialized |
                        |   Data(BSS)   |
                        +---------------+
                        |  Initialized  |
                        |     Data      |
                        +---------------+
                        |   Read Only   |
                        |     data      |
                        |       +       |
                        |     code      |
                        +---------------+ Lowest Address 0X00000000
```
The above diagram shows how the 4GB of virtual address space of any 32 Binary
looks like when it is loaded into the memory. For understanding I have drawn the
stack in top down order, i.e highest address at the top and lowest at the
bottom.
Lets's understand the different sections (from top):
1. The very first section store the command line arguments and environment
variables that are passed to the program during its execution.

2. **Stack**: This stores the dynamic variable created inside the fucntion.
**Don't confuse yourself with the dynamic variable generated by \*alloc family
of fucntions.** Every varibale is dynamic in program in the sense that every
variable is assigned memory during run time only. The noramlly declared variables
inside fucntions are stored onto the stack. **This grows in reverse order** ie.
from hightest address to lowest address.

3. **Heap**: Dynamic variables that are created by \*alloc family of fucntions.

4. **BSS**: This section stores the uninitialized(gloabl + static) variables.
They are automatically intialized to **0**.

5. Next section stores the varibale(**gloabl + static**) which are initialized
to some value.

6. The last section stores all the **read-only** variables and code of the
program in binary language.
